#!/usr/bin/env ruby
# frozen_string_literal: true

require "socket"

PATH = "socket.sock"

class WorkerPool
  attr_reader(:mutex, :tasks, :min_workers, :max_workers, :workers, :tasks, :stats_ractor, :actor, :processed)
  attr_accessor(:idle)

  def initialize(min_workers: 5, max_workers: 5)
    @idle = 0
    @processed = 0
    @tasks = []
    @min_workers = min_workers.freeze
    @max_workers = max_workers.freeze
    @actor = Ractor.new { loop { Ractor.yield(Ractor.receive) } }
    @stats_ractor = Ractor.new do
      loop do
        Ractor.yield(Ractor.receive)
      end
    end

    Thread.new do
      loop do
        c = @stats_ractor.take
        if c == 1
          @idle += 1
        elsif c == -1
          @idle -= 1
        elsif c == 0
          @processed += 1
        end
      end
    end

    @workers = min_workers.times.map { spawn_worker }
  end

  def spawn_worker
    Ractor.new(actor, stats_ractor) do |actor, stats_ractor|
      loop do
        stats_ractor.send(1)
        work = actor.take
        stats_ractor.send(-1)
        work.process
        stats_ractor.send(0)
      end
    end
  end

  def <<(work)
    workers << spawn_worker if spawn_more?
    actor.send(work)
  end

  def pool_capacity
    (max_workers - workers.length) + idle
  end

  def spawn_more?
    idle < 1 && workers.length < max_workers
  end
end


class Work
  def process
    "Processing work in #{Thread.current}"
    70000000.times do
      
    end
  end
end

class Server
  attr_reader :socket, :worker_pool

  def initialize(worker_pool)
    File.unlink(PATH) if File.exist?(PATH)
    @socket = UNIXServer.new(PATH)
    @worker_pool = worker_pool
    @start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)
  end

  def run
    loop do
      puts("Ractored server started, ready to accept connections")
      Thread.start(socket.accept) do |client|
        puts "Processing new request"
        # Use recv instead of readpartial to avoid EOFError when client closes
        data = client.recv(1000).strip

        if data == "STREAM"
          loop do
            print_stats(client)
            sleep 0.5
          end
        else
          print_stats(client)
          client.close
        end
      rescue Errno::EPIPE
        puts "Client disconnected"
        client.close
      end
    end
  rescue SignalException => e
    socket.close
  end

  def print_stats(client)
    client.puts "pool capacity: #{worker_pool.pool_capacity}"
    client.puts "idle: #{worker_pool.idle}"
    client.puts "workers: #{worker_pool.workers.length}"
    client.puts "processed: #{worker_pool.processed} in #{Process.clock_gettime(Process::CLOCK_MONOTONIC) - @start_time} seconds"
    # client.puts "backlog: #{worker_pool.tasks.length}"
  end
end


class Launcher
  attr_reader :worker_pool

  def initialize(worker_pool: nil)
    @worker_pool = worker_pool || WorkerPool.new(min_workers: 5, max_workers: 8)
  end

  def launch
    Thread.new do
      Server.new(worker_pool).run
    end

    while true
      sleep(rand(0..1.5))
      worker_pool << Work.new
    end
  end
end



Launcher.new.launch




# require "thwait"
# semaphore = Mutex.new
# varia = ConditionVariable.new


# arr = []

# th1 = Thread.new {
  
#   semaphore.synchronize {
#     while true
#       puts "idle worker 1"
#       arr << arr.fetch(-1, 0) + 5
#      if arr.length > 100
#       varia.signal
#      end
#       break if arr.length > 200
#     end
#   }
# }

# th2 = Thread.new {
#   semaphore.synchronize {
#     while true
#       puts "idle worker 2"
#       # deadlock occurs when a worker releases the lock on the mutex (with a CV) but there are no other workers awake to acquire the lock.
#       varia.wait(semaphore)
#       arr << arr.fetch(-1, 0) + 3
#       varia.signal if arr.length > 100
#       break if arr.length > 300
#     end
#   }
# }

# semaphore.synchronize { while true; end }

# puts th1, th2
# # puts th1, th2, Thread.main
# th1.join
# th2.join


# p arr


